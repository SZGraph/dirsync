#!/usr/local/bin/perl

#############################################################################################################################################
### Скрипт разработан для рекурсивной синхронизации директории ПРИЕМНИКА с директорией ИСТОЧНИКА. Програмка будет полезна для синхронизации разрозненных личных проектов, например, при подготовке к почистке компьютера.
### Файлы директории ИСТОЧНИКА не удаляются. Вся информация о перемещении файлов печатается в STDOUT. Для синхронизации в обоих направлениях вызовите скрипт дважды поменяв местами параметры имени и пути к ПРИЕМНИКУ и ИСТОЧНИКУ. Для сохранения информации о синхронизации перенаправьте вывод STDOUT в файл в консоли.
### 
### Отличие программы dirsync:

### Программа сравнивает файлы в ИСТОЧНИКЕ и ПРИЕМНИКЕ:
### 1. по имени;
### 2. по размеру файла;
### 3. по содержанию (в случае равных размеров);
### 4. по дате создания.
### Первым приоритетом для синхронизации обладает имя файла. Если в ПРИЕМНИКЕ нет файла или директории с тем же именем, что и в ИСТОЧНИКЕ то они целиком копируются в ПРИЕМНИК. 
### Второй приоритет у размера файла. Если файлы равны, то они сравниваются по содержанию (актуально для случаев где в файле изменен параметр, цифра). Если содержания файла ИСТОЧНИКА и ПРИЕМНИКА идентичны, то копирование не произойдет. Заметим, что сравнение файлов ограничено по-умолчанию первыми 25 МБ (может быть изменена через переменную $PARAM_s_bytes_compare*). Так же, через переменную $PARAM_s_ignore_bytes_compare* можно задать количество первых байт которые не будут участвовать в сравнении (по умолчанию 0). 
### Если файлы не равны по размеру или содержанию, то учитывается время создания файлов.
### В зависимости от времени создания файлов ИСТОЧНИКА и ПРИЕМНИКА выполняется одно из действий:
### 
### -   Если в ПРИЕМНИКЕ более старый файл, то к его имени добавляется ЗАДАННЫЙ пользователем суффикс перед расширением файла 
### 	 (параметр $PARAM_s_suffix_old_file*). Файл ИСТОЧНИКА копируется с сохранением своего имени.
###     Если файл в ИСТОЧНИКЕ будет снова изменен и синхронизирован, то предыдущий перемещенный файл ИСТОЧНИКА с идентичным именем будет 
###     переименован с добавлением порядкового номера к суффиксу.
### -   Если в ИСТОЧНИКЕ более старый файл, то он копируется с сохранением своего имени в архивную директорию с ЗАДАННЫМ пользователем именем 
### 	 (параметр $PARAM_s_archive_dir_name*) рядом с файлом ПРИЕМНИКА.
###     Если файл в ПРИЕМНИКЕ будет изменен и синхронизирован, при этом файл в ИСТОЧНИКЕ окажется не совпадающим с файлом из архивной директории, 
###     то файл из архивной директории получит к имени суффикс и свой порядковый номер.
###     
### *Примечание. Переменные через которые задаются указанные настройки собраны в разделе НАСТРАИВАЕМЫЕ ПАРАМЕТРЫ.
### 
### Пользовательские настройки синхронизации ПРИЕМНИКА
### 
### Вы можете отсеять ненужные файлы ИСТОЧНИКА при синхронизации. Для этого в список @PARAM_a_nonsinchronize_elements* добавьте своё регулярное выражение 'regex', отвечающее имени непредназначенного для синхронизации файла. 'regex' будет применено к именам файлов каждой директории ИСТОЧНИКА.
### Синхроницация файлов ПРИЕМНИКА осуществляется по следующим правилам.
### Копирование файлов и директорий осуществляется с помощью двух функций ($file_copy_sub и $dir_copy_sub), которые вынесены для удобства настроек в раздел НАСТРАИВАЕМЫЕ ФУНКЦИИ КОПИРОВАНИЯ.
### Копирование осуществляется путем конвеерного архивирования файла в STDOUT и разархивирования в нужную директорию с сохранением прав доступа и времени создания файлов.
### 
### Зависимости программы dirsync:
### 
### Скрипт написан на perl v5.32.1
### Скрипт использует системные функции cmp, mkdir, zip, tar, zcat и адаптирован под следующие версиии:
### cmp (GNU coreutils) 8.32 - для сравнения файлов;
### mkdir  (GNU coreutils) 8.32 - для создания каталогов;
### zip 3.0 (July 5th 2008) - для создания zip архивов;
### tar (GNU tar) 1.34 - для работы tar архивами;
### zcat (gzip) 1.10 - для разархивирования из STDOUT.
### C другими версиями данных программ работоспособность скрипта не проверялась.
### 
### Замечание! В версии 8.32 функции сравнения файлов (cmp) при сравнении идентичных файлов возвращается пустая строка с переносом. Это ловит блок if ($s_compare=~m/^\s*$/ ) в теле функции FileComparator(…). Если в другой версии она будет возвращать другое, то регулярное выражение в if нужно будет адаптировать под него.
### -------------------------------------------------------------------------------------------------------------------------- 
### Цель скрипта: Синхронизировать директории при этом сохранять одноименные но различающиеся в содержании файлы подходящим способом.
### --------------------------------------------------------------------------------------------------------------------------
### Алгоритм: 
### 1. Получение директорий от входных параметров
### 2. Вызов рекурсивной функции RUN(...) которая синхронизирует каталоги
### --------------------------------------------------------------------------------------------------------------------------
### Пример использования:
### `perl dirsync.pl <директория ИСТОЧНИКА> <директория ПРИЕМНИКА>`\
### Например, ```perl dirsync.pl /home/.../.github /media/...github > dirsync_log.txt``` (Информация о синхронизации отпечатывается в файл dirsync_log.txt. Для больших прав при копировании и чтении запустите с крипт с правами администратора, например, `sudo perl dirsync.pl...`).
### --------------------------------------------------------------------------------------------------------------------------
### Результат выполнения скрипта: В терминале или в файле печатается информация о совершённых действиях при синхронизации.
### Пример отпечатанного текста в файле dirsync_log.txt:
### 	Отчет от 02.11.2022 22:18:42 о синхронизации директории ИСТОЧНИКА
### Файл ПРИЕМНИКА:	/media/facer/Date/test/github;
### Файл ИСТОЧНИКА:	/home/facer/go/src/go.opencensus.io/.github.
### 
### Обозначения:
### - "old" - имя директории в которую помещаются файлы ИСТОЧНИКА рядом с более новым файлом ПРИЕМНИКА, отличающимся по содержанию.
### - "_old" - суффикс перед расширением файла. Получают файлы ИСТОЧНИКА, если оказываются старее файлов ПРИЕМНИКА.
###   Также помечаются файлы ИСТОЧНИКА в директориях "old" если есть отличающиеся аналоги.
###   Больший номер после суффикса соответствует файлу, который позже остальных получил суффикс.
### 
### o--> /home/facer/go/src/go.opencensus.io/.github
### Файл ИСТОЧНИКА /CODEOWNERS старее. Помещен в папку old.
### 	o--> /home/facer/go/src/go.opencensus.io/.github/ISSUE_TEMPLATE
### 	Файл ИСТОЧНИКА /ISSUE_TEMPLATE/bug_report.md старее. Помещен в папку old.
### 	Файлы в ИСТОЧНИКЕ и ПРИЕМНИКЕ /ISSUE_TEMPLATE/feature_request.md подобны.
### 	o--> /home/facer/go/src/go.opencensus.io/.github/workflows
### 	Файлы в ИСТОЧНИКЕ и ПРИЕМНИКЕ /workflows/build.yml подобны.
### 
### Число рекурсивно обойденных директорий в ИСТОЧНИКЕ - 3.
### --------------------------------------------------------------------------------------------------------------------------
### Создание: 29.10.2022 г., Сергей Злобин
### Последняя модификация: 04.11.2022 г., Сергей Злобин
#############################################################################################################################################

#Строгая прагма отключает опасные выражения Perl, которые могут вести себя неожиданно.
use strict;
#Все ошибки интерпретировать как фатальные
use warnings FATAL => 'all';
#Установка кодировки скрипта
use utf8;

#Настройка кодировки стандартного выхода (STDOUT)
binmode(STDOUT, "encoding(UTF-8)");
	
#use File::Copy;
#package main;

#Прототип рекурсивной функции
sub RUN($;$);
sub FileComparator($$);

#=================================================================
# НАСТРАИВАЕМЫЕ ПАРАМЕТРЫ
#=================================================================
# Имя АРХИВНОЙ директории которая будет создаваться в директориях ПРИЕМНИКА рядом с тем файлом ПРИЕМНИКА, который отличается в содержании 
# от одноименного файла ИСТОЧНИКА и создан позже.
my $PARAM_s_archive_dir_name = "old";
	
# СУФФИКС который добавляется в директориях ПРИЕМНИКА перед расширением файла из ИСТОЧНИКА или из ПРИЕМНИКА, в случае если один из них 
# старее одноименного ему и имеет различие в содержании.
my $PARAM_s_suffix_old_file = "_old";

# Количество сравниваемых битов для вывода о сходстве или различии файлов. По-умолчанию первыми 25 МБ
my $PARAM_s_bytes_compare = '25MB';

# Количество первых байт которые не будут участвовать в сравнении (по умолчанию 0).
my $PARAM_s_ignore_bytes_compare = 0;

# Список не синхронизируемых файлов, директорий и ссылок.
# Можете отсеять ненужные файлы ИСТОЧНИКА при синхронизации. 
# Для этого в список добавьте своё регулярное выражение 'regex', отвечающее имени непредназначенного для синхронизации файла. 
# 'regex' будет применено к именам файлов каждой директории ИСТОЧНИКА.
# '\.','\.\.' - два *обязательных шаблона* для удаления из синхронизируемых объектов (ссылки перехода из директории), без них произойдет зацикливание программы.
# 'CVS' - не синхронизируются CVS файлы (можно убрать из списка, если желаете синхронизировать эти файлы)
my @PARAM_a_nonsinchronize_elements = ('\.','\.\.',' ','CVS');
#=================================================================

#=================================================================
# НАСТРАИВАЕМЫЕ ФУНКЦИИ КОПИРОВАНИЯ
#=================================================================
# Функция копирования файлов
# Для копирования используется конвеер с функциями zip и zcat. 
# Функция zip используется для печати файла в stdout (-)
# Функция 
my $file_copy_sub = sub ($$) {my ($i_s_source_file, $i_s_dest_file)=@_;# Инициализация входных параметров функций
	qx(zip - '$i_s_source_file'|zcat > '$i_s_dest_file');
	};
#Вызов функции: &$dir_copy_sub('/media/.../Coding_theory/ReedMullerExamples.pdf','/media/.../Coding_theory_copy/ReedMullerExamples.pdf');

# Функция копирования директории
# Для копирования используется конвеер с функцией tar. Функция tar сначала в STDOUT (указан через черту "-") создает архив, после этого в папке $i_s_source_dir его извлекает.
# Функция tar при создании архива вызывается с параметрами -cf со следующим значением:
#-c, --create     		- создание нового архива (настройка основного режима работы);
#-f, --file=АРХИВ 		- использовать файл или устройство АРХИВ (настройка выбора и переключения устройств).
# Функция tar при открытии архива вызывается с параметрами -xf, -C и --strip-components со следующим значением:
#-C, --directory=КАТАЛОГ- перейти в КАТАЛОГ (настройка имени выбранного локального файла);
#-x, --extract, --get   - извлечение файлов из архива (настройка основного режима работы);
#-f, --file=АРХИВ 		- использовать файл или устройство АРХИВ (настройка выбора и переключения устройств);
#--strip-components		- удалять указанное ЧИСЛО начальных компонентов из имён файлов перед извлечением (настройка преобразования имён файлов).
my $dir_copy_sub = sub ($$) {my ($i_s_source_dir, $i_s_dest_dir)=@_;# Инициализация входных параметров функций
	my $s_source_path_depth = scalar split(/\//,$i_s_source_dir);#глубина директории источника
	if ($i_s_source_dir=~m/^\//){$s_source_path_depth -= 1};#уточнение глубины директории источника
	qx(tar -cf - '$i_s_source_dir'|tar -C '$i_s_dest_dir' -xf - --strip-components $s_source_path_depth);#конвеер копирования директории
};
#Вызов функции: &$dir_copy_sub('/media/.../Coding_theory','/media/.../Coding_theory_copy');

#=================================================================

#=================================================================
# ПОЛУЧЕНИЕ ВХОДНЫХ ПАРАМЕТРОВ ПОДАННЫХ ПРИ ВЫЗОВЕ СКРИПТА
#=================================================================

# Директория ИСТОЧНИКА (скаляр). Задается через входной параметр при вызове скрипта.
my $PARAM_s_start_source_dir = $ARGV[0];
# Директория ПРИЕМНИКА (скаляр). Задается через входной параметр при вызове скрипта.
my $PARAM_s_start_dest_dir = $ARGV[1];


#=================================================================
# I. Определение рекурсивной функции синхронизации - RUN(...). 
#=================================================================

#=================================================================
# Описание: Функция переносит файлы из ИСТОЧНИКА в ПРИЕМНИК.
# Если в ПРИЕМНИКЕ оказывается более новый файл, то файл из ИСТОЧНИКА помещается в заданную директорию рядом с новым файлом.
# Если в ПРИЕМНИКЕ более старый файл, то к нему добавляется заданный суффикс и более новый файл сохраняет свое имя.
#----------------------------------------------------------------------------------------------------------------------------- 
# Входные параметры:
# - $i_s_source_dir	- имя директории (скаляр).
# - $i_s_level		- глубина текущей директории (скаляр).
# Заметка: i - input (вход). Параметр с информацией подаваемой на вход. 
#-----------------------------------------------------------------------------------------------------------------------------
# Выходные параметры: 
# Выходные параметры через return: 
# - $o_s_num_recurse_run - число рекурсивных вызовов функции (скаляр).
#----------------------------------------------------------------------------------------------------------------------------- 
# Использованные функции:
# Внутренние:
# Функция ведения архивов — ArchiveManager(…);
# Функция сравнения файлов — FileComparator(…).
# Внешние: 
# Функция копирования файлов - cp;
# Функция создания каталогов - mkdir.
#----------------------------------------------------------------------------------------------------------------------------- 
# Алгоритм: 
# 1. Подготовка параметров функции
# 2. Печать информации о проделанной работе (добавлении поддиректории, дописывания файла...)
# 3. Возврат числа вызовов RUN(...)
#=================================================================	

sub RUN($;$)
{
	
	#Получение входных параметров при вызове функции
	my ($i_s_source_dir,$i_s_level) = @_;
	
	# Проверка заданности необязательного входного параметра глубины текущей директории
	if (!defined($i_s_level))
	{
		# Глубина текущей директории НЕ задана
		$i_s_level = 0;
	}
	else
	{
		# Глубина текущей директории задана. Прибавляем 1
		$i_s_level += 1;
	}
	
	#=================================================================
	# 1. Подготовка параметров используемых в функции.
	#=================================================================

	# Список содержимого в директории i_s_working_directory_name;
	my @a_read_files = ();
	
	# Список директорий в директории i_s_working_directory_name;
	my @a_dirs_in_source = ();
	
	# Число вызовов функции (скаляр). Начальное значение 1.
	my $o_s_num_recurse_run = 1;
	
	#Объявление элементов синхронизации: ИСТОЧНИК  (скаляр) и ПРИЕМНИК (скаляр)
	my $s_source_element;
	my $s_dest_element;
	
	#Отступ для печати (скаляр)
	my $s_level_shift = "\t"x$i_s_level;
	
	#Результат сравнения файла ИСТОЧНИКА и ПРИЕМНИКА (скаляр)
	my $s_result_compare;
	
	#Путь и имя к текущему файлу в архивной директории ($PARAM_s_archive_dir_name) (скаляр)
	my $s_element_in_arch;
	#=================================================================
	# 2. Синхронизация
	#=================================================================
	# Проверка доступности чтения директории ИСТОЧНИКА
	if (-R $i_s_source_dir)
	{
		# Текущая директория ИСТОЧНИКА доступна для чтения
		
		# Печать разделителя и текущей директории
		print $s_level_shift."o--> $i_s_source_dir\n";
	}
	else
	{
		# Текущая директория ИСТОЧНИКА НЕ доступна для чтения
		
		print $s_level_shift."$i_s_source_dir - Директория ИСТОЧНИКА НЕ доступна для чтения!\n";
		return 	0;
	}
			
	# Открытие директории и назначение filehandle в переменной $oref_dh
	opendir(my $oref_dh, $i_s_source_dir);
	# Чтение содержимого директории в @a_read_files
	@a_read_files = readdir $oref_dh;
	# Закрытие директории.
	close $oref_dh;
	
	#Список с содержимым директории 
	my $s_read_files = join("\n",@a_read_files);
	#print "\$s_read_files:$s_read_files\n";
	
	#Очистка синхронизируемых ссылок и директорий
	foreach my $s_unit_nonsinchr (@PARAM_a_nonsinchronize_elements)
	{
		$s_read_files =~ s/(\n|^)$s_unit_nonsinchr(?:\n|$)/$1/g;
	}
	
	#Сортированный список файлов и папок отчищенный от синхронизируемого содержимого
	@a_read_files = sort(split(/\n/,$s_read_files));
	#print "\@a_read_files:@a_read_files\n";
	
	# Получение текущей директории в ПРИЕМНИКЕ
	my $s_inner_directory_name = $i_s_source_dir;
	
	# Удаление пути до начальной директории ИСТОЧНИКА
	$s_inner_directory_name =~ s/$PARAM_s_start_source_dir//;
	
	#Путь до текущей директории в ПРИЕМНИКЕ
	my $s_dest_dir = "$PARAM_s_start_dest_dir$s_inner_directory_name";
	
	#----------------------------------------------------------
	# ПЕРЕМЕЩЕНИЕ ФАЙЛОВ ИЗ ИСТОЧНИКА В ПРИЕМНИК - начало
	#----------------------------------------------------------

	# Проверка, существует ли текущая директория в ПРИЕМНИКЕ
	if (-e $s_dest_dir)
	{
		#Директория в ПРИЕМНИКЕ существует
		
		# Обходим все файлы из текущей директории в ПРИЕМНИКЕ
		foreach my $s_dir_element (@a_read_files)
		{
			#$s_dir_element - содержит текущий файл или директорию
			
			#Задаём элементы синхронизации: ИСТОЧНИК и ПРИЕМНИК
			$s_source_element = "$i_s_source_dir/$s_dir_element";
			$s_dest_element = "$s_dest_dir/$s_dir_element";
			
			#Проверка директория ли $s_dir_element
			if (-d $s_source_element)
			{
				# $s_dir_element - директория
			
				#Добавляем её в список для дальнейшей рекурсивной обработки
				push @a_dirs_in_source, $s_source_element;
			
			}
			else
			{
				# $s_dir_element - файл 
				
				# Проверка существования подобного файла в соответствующей директории ПРИЕМНИКА
				if (-e $s_dest_element)
				{
					#Да, в ПРИЕМНИКЕ существует файл с тем же именем
					
					#-----------------------------------------------------------
					# Вызываем функцию сравнения двух файлов
					#-----------------------------------------------------------
					# 0 - файлы подобны
					# 1 - файлы различаются - ИСТОЧНИК старее
					# 2 - файлы различаются - ПРИЕМНИК старее
					# 3 - ошибка
					$s_result_compare = FileComparator($s_source_element, $s_dest_element);
					
					# Обработка результата сравнения - НАЧАЛО
					
					#-----------------------------------------------------------
					# Обработка ситуации: файлы подобны
					#-----------------------------------------------------------
					if ($s_result_compare == 0)
					{
						# файлы подобны
						
						print $s_level_shift."Файлы в ИСТОЧНИКЕ и ПРИЕМНИКЕ $s_inner_directory_name/$s_dir_element подобны.\n";
						#удаление элемента из ИСТОЧНИКА
						#unlink $s_source_element;
					}
					#-----------------------------------------------------------
					# Обработка ситуации: файлы различаются - ИСТОЧНИК старее
					#-----------------------------------------------------------
					if ($s_result_compare == 1)
					{
						# файлы различаются - ИСТОЧНИК старее

						# Создание архивной папки в соответствующей директории ПРИЕМНИКА куда попадает файл из ИСТОЧНИКА, так как он старее
						if (!-e "$s_dest_dir/$PARAM_s_archive_dir_name")
						{
							# Архивная папка НЕ существует
							
							# Создание архивной папки
							mkdir( "$s_dest_dir/$PARAM_s_archive_dir_name" );
							
							#Вызываем функцию копирования файла. Копируем файл ИСТОЧНИКА в архивную папку ПРИЕМНИКА, расположенную рядом с аналогичным файлом
							&$file_copy_sub($s_source_element,"$s_dest_dir/$PARAM_s_archive_dir_name/$s_dir_element");
											
							print $s_level_shift."Файл ИСТОЧНИКА $s_inner_directory_name/$s_dir_element старее. Помещен в папку old.\n" if (-e "$s_dest_dir/$PARAM_s_archive_dir_name");
							
						}
						else
						{
							# Архивная папка существует
							
							print $s_level_shift."Файл ИСТОЧНИКА $s_inner_directory_name/$s_dir_element старее. Архивная папка существует.\n";
							
							#Имя и путь до файла в архивной папке с именем текущего файла из ИСТОЧНИКА
							$s_element_in_arch = "$s_dest_dir/$PARAM_s_archive_dir_name/$s_dir_element";
							
							# Сравнение текущего файла ИСТОЧНИКА с файлом в архиве. 
							$s_result_compare = FileComparator($s_source_element, $s_element_in_arch);
							
							# Если проверка даст 1 или 2 - файл из ИСТОЧНИКА не копируем.
							if (($s_result_compare == 1) or ($s_result_compare == 2))
							{
								# Переносим в архивный файл ПРИЕМНИКА текущий файл и упорядочиваем архивные файлы - НАЧАЛО
								
								# Вызываем функцию ArchiveManager(...) с параметрами
								# 1 - файл ИСТОЧНИКА ($s_source_element)
								# 2 - директория файла ИСТОЧНИКА ($s_dir_element)
								# 3 - директория файла ПРИЕМНИКА ("$s_dest_dir/$PARAM_s_archive_dir_name")
								# 4 - текущий сдвиг для печати ($s_level_shift)
								# 5 - общий путь у ПРИЕМНИКА и ИСТОЧНИКА до текущего файла ("$s_inner_directory_name/$PARAM_s_archive_dir_name")
								ArchiveManager($s_source_element, $s_dir_element, 
													"$s_dest_dir/$PARAM_s_archive_dir_name", 
													$s_level_shift, 
													"$s_inner_directory_name/$PARAM_s_archive_dir_name");

								# Переносим в архивный файл ПРИЕМНИКА текущий файл и упорядочиваем архивные файлы - КОНЕЦ

							}
							# Если проверка даст 0 или 3 - файл из ИСТОЧНИКА не копируем.
							if ($s_result_compare == 0)
							{
								print $s_level_shift."Файл ИСТОЧНИКА совпадает с файлом в архиве.\n";
							}
							if ($s_result_compare == 3)
							{
								print $s_level_shift."Файл $s_inner_directory_name/$s_dir_element - не перемещён!!!\n";
							}
							# Сбрасываем переменную $s_result_compare, чтобы не войти в обработку какой-либо ситуации
							$s_result_compare = -1;
							
						}# Конец - Архивная папка существует
					}# Конец - Обработка ситуации: файлы различаются - ИСТОЧНИК старее
					
					#-----------------------------------------------------------
					# Обработка ситуации: файлы различаются - ПРИЕМНИК старее
					#-----------------------------------------------------------
					if ($s_result_compare == 2)
					{
						# файлы различаются - ПРИЕМНИК старее
						
						print $s_level_shift."Файл ПРИЕМНИКА $s_inner_directory_name/$s_dir_element старее. К его имени будет добавлен суффикс:\n";
						
						# Переносим текущий файл ИСТОЧНИКА в ПРИЕМНИК, а текущий файл ПРИЕМНИКА получает суффикс и максимальный номер - НАЧАЛО
						# Вызываем функцию ArchiveManager(...) с параметрами
						# 1 - файл ИСТОЧНИКА ($s_source_element)
						# 2 - директория файла ИСТОЧНИКА ($s_dir_element)
						# 3 - директория файла ПРИЕМНИКА ($s_dest_dir)
						# 4 - текущий сдвиг для печати ($s_level_shift)
						# 5 - общий путь у ПРИЕМНИКА и ИСТОЧНИКА до текущего файла ($s_inner_directory_name)
						ArchiveManager($s_source_element, $s_dir_element, $s_dest_dir, $s_level_shift, $s_inner_directory_name);

						# Переносим текущий файл ИСТОЧНИКА в ПРИЕМНИК, а текущий файл ПРИЕМНИКА получает суффикс и максимальный номер - КОНЕЦ
					
					}
					
					#-----------------------------------------------------------
					# Обработка ситуации: ошибка в функции FileComparator(...) 
					#-----------------------------------------------------------
					if ($s_result_compare == 3)
					{
						# ошибка в функции FileComparator(...) 
						
						print $s_level_shift."Файл $s_inner_directory_name/$s_dir_element - не перемещён!!!\n";
						# переходим к следующему элементу списка @a_read_files
						next;
					}
					
					# Обработка результата сравнения - КОНЕЦ				
					
				}
				else
				{
					#Нет, в ПРИЕМНИКЕ не существует файл с тем же именем
					
					#Вызываем функцию копирования файла. Копируем файл из текущей директории ИСТОЧНИКА в соответствующую директорию в ПРИЕМНИКЕ
					&$file_copy_sub($s_source_element,"$s_dest_element");
					
					print $s_level_shift."Отсутствующий в ПРИЕМНИКЕ файл $s_inner_directory_name/$s_dir_element скопирован.\n" if (-e $s_dest_dir);
				}
				
			}

		}
	}
	else
	{
		# Директория в ПРИЕМНИКЕ НЕ существует
		
		# Создаём директорию в ПРИЕМНИКЕ
		# -p - создавать родительские каталоги при необходимости
		qx(mkdir -p '$s_dest_dir');
		
		# Вызываем функцию копирования директории. Копирует директорию ИСТОЧНИКА, отсутствующую в ПРИЕМНИКЕ в ПРИЕМНИК.
		&$dir_copy_sub($i_s_source_dir,$s_dest_dir);

		print $s_level_shift."Директория $s_inner_directory_name полностью скопирована в ПРИЕМНИК.\n";
	}# Конец - Проверка, существует ли аналогичная директория в ПРИЕМНИКЕ
	
	#----------------------------------------------------------
	# ПЕРЕМЕЩЕНИЕ ФАЙЛОВ ИЗ ИСТОЧНИКА В ПРИЕМНИК - конец
	#----------------------------------------------------------
	
	
	#рекурсия - НАЧАЛО
	
	# Обходим все файлы, которые являются директориями из текущей директории ПРИЕМНИКА
	foreach my $s_dir (@a_dirs_in_source)
	{
		# $s_dir - содержит имя папки из текущей директории ИСТОЧНИКА
		
		#рекурсивный вызов функции с подачей директорий из текущей
		$o_s_num_recurse_run += RUN($s_dir,$i_s_level);
	} 
	
	#рекурсия - КОНЕЦ
	
	# Возвращаем число рекурсивных вызовов RUN(...)
	return $o_s_num_recurse_run;
}

# Функция RUN(...) - КОНЕЦ
#=================================================================

#=================================================================
# II. Функция ведения архивов - ArchiveManager(...). 
#=================================================================

#=================================================================
# Описание:  Функция копирует файл ИСТОЧНИКА в директорию ПРИЕМНИКА и следит за нумерацией устаревших файлов, помеченных суффиксом
#----------------------------------------------------------------------------------------------------------------------------- 
# Входные параметры: 
# Пояснение: Входные параметры - параметры, которые подают при вызове функции
# - $s_source_element - полный путь и имя файла ИСТОЧНИКА (скаляр);
# - $s_dir_element - полный путь и имя директории файла ИСТОЧНИКА (скаляр);
# - $s_dest_dir - полный путь и имя директории файла ПРИЕМНИКА (скаляр);
# - $s_level_shift - текущий сдвиг для печати (скаляр);
# - $s_inner_directory_name - общий путь у ПРИЕМНИКА и ИСТОЧНИКА до переносимого файла ИСТОЧНИКА (скаляр).
#-----------------------------------------------------------------------------------------------------------------------------
# Выходные параметры: печать сообщений в STDOUT
#----------------------------------------------------------------------------------------------------------------------------- 
# Алгоритм: 
# 1. Получаем имя и путь старого файла с суффиксом и шаблон (имя+суффикс)
# 2. Чтение в директории одноименных файлов с суффиксом
# 3. Переименование списка одноименных файлов с суффиксом в соответствии с порядком
# 4. Добавление номера к файлу с суффиксом без номера (если есть)
# 5. Переименование текущего файла в ПРИЕМНИКЕ (старого, если существует): даём ему суффикс и последний порядковый номер
# 6. Копирование текущего файла ИСТОЧНИКА в ПРИЕМНИК.
#=================================================================
sub ArchiveManager($$$$$)
{
	my ($s_source_element, $s_dir_element, $s_dest_dir, $s_level_shift, $s_inner_directory_name) = @_;
	
	#Элемент синхронизации в ПРИЕМНИКЕ (скалаяр)
	my $s_dest_element = "$s_dest_dir/$s_dir_element";
	
	# Список из элементов имени старого файла разделенных точкой
	my @a_old_file_elem;
	
	# Шаблон имени старого файла с суффиксом (скаляр)
	my $s_pattern_old_file;
	
	#"Расширение файла" (скаляр)
	my $s_extens_file;
	
	#Путь и имя для более старого файла в ПРИЕМНИКЕ чем в ИСТОЧНИКЕ (скаляр)
	my $s_dest_element_old;
	
	#Текущий номер в имени старого файла с суффиксом (скаляр)
	my $s_num_file;
	
	#Список файлов в текущей директории ПРИЕМНИКА, если в нем есть более старые файлы
	my @a_read_files_in_dest_dir;
	
	#Вспомогательный счетчик (скаляр)
	my $s_count;
	
	#Имя файла с суффиксом после исправления порядкового номера (скаляр)
	my $s_rename_old_file;
		
	# 1. Получаем имя и путь старого файла с суффиксом и шаблон (имя+суффикс) - НАЧАЛО
		
	# Получаем элементы имени разделенные точками
	@a_old_file_elem = split(/\./,$s_dir_element);

	# Получение расширения и шаблона файла (имя+суффикс) в зависимости от числа точек в имени
	if (scalar @a_old_file_elem == 1)
	{
		# В имени НЕТ точки (расширения)
		
		# ШАБЛОН - Имя конкатенируем с суффиксом
		$s_pattern_old_file = $s_dir_element.$PARAM_s_suffix_old_file;
		
		#"Расширение файла"
		$s_extens_file = "";
		
	}
	elsif ((scalar @a_old_file_elem >= 3) and 
	($a_old_file_elem[-2] le "xxxx") and
	($a_old_file_elem[-1] le "xxxx"))
	{
		# В имени как минимум два расширения
		
		# ШАБЛОН - Имя без предпоследнего элемента после точки ("расширения") конкатенируем с суффиксом
		$s_pattern_old_file = join(".", @a_old_file_elem[0..$#a_old_file_elem-2]).$PARAM_s_suffix_old_file;
		
		#"Расширение файла"
		$s_extens_file = ".".$a_old_file_elem[-2].".".$a_old_file_elem[-1];
	}
	else
	{
		# В имени как минимум одно расширение
		
		# ШАБЛОН - Имя без последнего элемента после точки ("расширения") конкатенируем с суффиксом
		$s_pattern_old_file = join(".", @a_old_file_elem[0..$#a_old_file_elem-1]).$PARAM_s_suffix_old_file;
		
		#"Расширение файла"
		$s_extens_file = ".".$a_old_file_elem[-1];
	}

	#Имя и путь к файлу: путь конкатенируем с шаблоном и затем с расширением
	$s_dest_element_old = "$s_dest_dir/$s_pattern_old_file".$s_extens_file;

	# 1. Получаем имя и путь старого файла с суффиксом и шаблон (имя+суффикс) - КОНЕЦ

	# 2. Чтение в директории одноименных файлов с суффиксом - НАЧАЛО
		
	# Открытие директории и назначение filehandle в переменной $oref_dh
	opendir(my $oref_dh, $s_dest_dir);
	# Чтение содержимого директории в @a_read_files_in_dest_dir
	@a_read_files_in_dest_dir = readdir $oref_dh;
	# Закрытие директории.
	close $oref_dh;

	#Получаем список с файлами с одним именем и суффиксом
	(@a_read_files_in_dest_dir) = join("\n",@a_read_files_in_dest_dir) =~ m/($s_pattern_old_file\d{0,5}?$s_extens_file)/g;

	# Сортируем список
	@a_read_files_in_dest_dir = sort(@a_read_files_in_dest_dir);

	# 2. Чтение в директории одноименных файлов с суффиксом - КОНЕЦ

	# 3. Переименование списка одноименных файлов с суффиксом в соответствии с порядком - НАЧАЛО

	# $s_count - порядковый номер списка от 0 до его размера -1. Устанавливаем в 0.
	$s_count = 0;

	# Проверяем каждый файл с суффиксом из списка на соответствие порядковому номеру. При не соответствии переименовываем. 
	# Если список пустой, цикл не работает
	foreach my $s_old_file (@a_read_files_in_dest_dir)							
	{
		# $s_old_file - имя файла из списка имен файлов с одним именем и суффиксом
		
		# Ищем номер файла после суффикса. Результат из группы (\d+) попадает в переменную $s_num_file
		($s_num_file) = $s_old_file =~ m/$s_pattern_old_file(\d*)/;
		
		# Проверяем имя: без номера ли в суффиксе
		if ($s_num_file=~m/^\s*$/)
		{
			#файл без номера. Должен получить максимальный порядковый номер из списка. Это будет выполнено ниже

			#Переходим к следующему файлу не увеличивая порядок
			next;
		}
		else
		{
			#файл c номером.
			
			# Проверяем номер после суффикса на соответствие порядку в списке
			if ($s_num_file != $s_count)
			{
				# Номер файла не соответствует требуемому порядку в списке. Переименовываем
				
				# Получаем элемент списка - файл с суффиксом + номер если есть
				$s_rename_old_file = $s_old_file;
				
				#Заменяем текущий номер в файле с суффиксом на $s_count
				$s_rename_old_file =~ s/($s_pattern_old_file)\d+/$1$s_count/;
				
				# Меняем имя файла в ПРИЕМНИКЕ
				rename ("$s_dest_dir/$s_old_file", "$s_dest_dir/$s_rename_old_file");
				
				print $s_level_shift."Файл из ПРИЕМНИКА $s_inner_directory_name/$s_old_file переименован: $s_inner_directory_name/$s_rename_old_file\n" 
				if (-e "$s_dest_dir/$s_rename_old_file");# Печатаем если существует файл
			}
		}
		
		# Увеличиваем порядковый номер на 1
		$s_count += 1;
	}

	# 3. Переименование списка одноименных файлов с суффиксом в соответствии с порядком - КОНЕЦ

	# 4. Добавление номера к файлу с суффиксом без номера (если есть) - НАЧАЛО
	if (-e "$s_dest_dir/$s_pattern_old_file".$s_extens_file)
	{
		# Файл с суффиксом без номера есть
		$s_rename_old_file = "$s_pattern_old_file".$s_count.$s_extens_file;
		# Добавляем к суффиксу без номера номер последнего элемента из списка
		rename ("$s_dest_dir/$s_pattern_old_file".$s_extens_file, "$s_dest_dir/$s_rename_old_file");
		
		print $s_level_shift."Файл из ПРИЕМНИКА $s_inner_directory_name/$s_pattern_old_file$s_extens_file переименован: $s_inner_directory_name/$s_rename_old_file\n" if (-e "$s_dest_dir/$s_rename_old_file");# Печатаем если существует файл
		
		#Увеличиваем счётчик
		$s_count += 1;
	}
	# 4. Добавление номера к файлу с суффиксом без номера (если есть) - КОНЕЦ

	# 5. Переименование текущего файла в ПРИЕМНИКЕ (старого, если существует): даём ему суффикс и последний порядковый номер - НАЧАЛО
	if (-e $s_dest_element)
	{
		#Имя и путь к текущему старому файлу ИСТОЧНИКА
		$s_rename_old_file = "$s_dest_dir/$s_pattern_old_file".$s_count.$s_extens_file;
				
		# Меняем имя текущего файла в ПРИЕМНИКЕ на имя с суффиксом и самым высоким номером
		rename ($s_dest_element, $s_rename_old_file);
		
		print $s_level_shift."Файл из ПРИЕМНИКА $s_inner_directory_name/$s_dir_element переименован: $s_inner_directory_name/$s_pattern_old_file$s_count$s_extens_file\n" if (-e $s_rename_old_file);# Печатаем если существует файл
	}
	# 5. Переименование текущего файла в ПРИЕМНИКЕ (старого): даём ему суффикс и последний порядковый номер - КОНЕЦ	
	
	# 6. Вызываем функцию копирования файла. Копирование текущего файла ИСТОЧНИКА в ПРИЕМНИК.
	&$file_copy_sub($s_source_element,$s_dest_element);
	
	if ($s_dest_dir =~ $PARAM_s_archive_dir_name)
	{
		print $s_level_shift."Файл из ИСТОЧНИКА $s_dir_element скопирован в архив в ПРИЕМНИКЕ $s_inner_directory_name/.\n" 
		if (-e "$s_dest_dir/$s_dir_element");# Печатаем если существует файл
	}
	else
	{
		print $s_level_shift."Файл из ИСТОЧНИКА $s_inner_directory_name/$s_dir_element скопирован в ПРИЕМНИК в $s_inner_directory_name/.\n" 
		if (-e "$s_dest_dir/$s_dir_element");# Печатаем если существует файл
	}
	
}
# Функция ArchiveManager(...) - КОНЕЦ
#=================================================================


#=================================================================
# III. Функция сравнения файлов - FileComparator(...). 
#=================================================================

#=================================================================
# Описание:  Функция сравнивает два файла с одинаковым именем (<файл1>,<файл2>) и возвращает:
#		0 — если файлы подобны;
#		1 — если файлы различаются - первый старее;
#		2 — если файлы различаются - второй старее;
#		3 — если произошла ошибка.
#----------------------------------------------------------------------------------------------------------------------------- 
# Входные параметры:
# - $i_s_file1 - полный путь и имя первого файла (<файл1>) (скаляр);
# - $i_s_file1 - полный путь и имя первого файла (<файл2>) (скаляр).
#-----------------------------------------------------------------------------------------------------------------------------
# Выходные параметры: 
# Выходные параметры чрез return: 
# - $o_s_result_compare - результат (скаляр);
#----------------------------------------------------------------------------------------------------------------------------- 
# Алгоритм: 
# 1. Получение информации от файлов и их сравнение
# 2. Возврат через return результата сравнения
#=================================================================
sub FileComparator($$)
{
	#Получение входных параметров при вызове функции
	my ($i_s_file1, $i_s_file2) = @_;
	
	# Возвращаемая функцией переменная. По умолчанию значение - ошибка
	my $o_s_result_compare = 3;
	
	# Проверка существования первого файла. Если не существует - ошибка
	if (!-e $i_s_file1){return $o_s_result_compare;}
	
	# Проверка существования второго файла. Если не существует - файлы различаются - второй старее
	if (!-e $i_s_file2){return 2;}
	
	# 1. Получение информации от файлов и их сравнение
	
	# Списки с информацией о файлах от функции stat:
	# 		$a_stat[0]	-	номер устройства файловой системы;
	# 		$a_stat[1]	-	номер inode;
	# 		$a_stat[2]	-	файловый режим (тип и разрешения);
	# 		$a_stat[3]	-	число обращений к файлу;
	# 		$a_stat[4]	-	цифровой идентификатор собственника файла;
	# 		$a_stat[5]	-	цифровой идентификатор группы собственника файла;
	# 		$a_stat[6]	-	идентификатор устройства;
	# 		$a_stat[7]	-	общий размер файла, в байтах;
	# 		$a_stat[8]	-	время последнего доступа в секундах от эпохи;
	# 		$a_stat[9]	-	время последнего изменения в секундах от эпохи;
	# 		$a_stat[10]	-	время изменения inode в секундах от эпохи (*);
	# 		$a_stat[11]	-	I/O размер в байтах;
	#		$a_stat[12]	-	число специфичных для системы блоков хранения файла, распределенных по диску (часто, но не всегда по 512 байтов)
	#		(*) Для разных типов файловой системы значения переменных могут не соответствовать. Переменная $a_stat[9] („время создания“) 
	# 		не меняет своего положения.
	my @a_stat_file1 = stat($i_s_file1);
	my @a_stat_file2 = stat($i_s_file2);
	
	# Разность даты создания файлов
	my $s_compare_dat = $a_stat_file1[9] - $a_stat_file2[9];
	
	# Проверяем созданы ли файлы в одно время (разность создания файлов равна 0)
	if  ($s_compare_dat == 0)
	{
		# файлы созданы в одно время
		$o_s_result_compare = 0;
	}
	# Проверяем создан ли второй файл позже первого (разность создания файлов меньше 0)
	if  ($s_compare_dat < 0)
	{
		# файлы различаются - первый старее
		$o_s_result_compare = 1;
	}
	# Проверяем создан ли первый файл позже второго (разность создания файлов больше 0)
	if  ($s_compare_dat > 0)
	{
		# файлы различаются - второй старее
		$o_s_result_compare = 2;
	}
	
	# 2. Проверяем равны ли по размеру файлы. Если равны, проверяем содержание. Оператор -s -возвращает размер файла в байтах. 
	# Мы не используем $a_stat[11], так как для разных типов файловой системы данный элемент списка может нести другую информацию.
	if (-s $i_s_file1 == -s $i_s_file2)
	{
		#Файлы имеют равный размер в байтах. Проверяем содержание
	
		#task! В версии 8.32 функции сравнения файлов (cmp) при сравнении идентичных файлов возвращается пустая строка с переносом. 
		# Это ловит блок `if ($s_compare=~m/^\s*$/ )` в теле функции FileComparator(…). Если в другой версии она будет возвращать другое, 
		# то регулярное выражение в if нужно будет адаптировать под него.) 
		#Побитовое сравнение файлов
		#-n, --bytes=25MB - сравниваем файл по первым 25 МВ
		#--ignore-initial=0:0 - пропускаем проверку в первых 0 битах в обоих файлах
		my $s_compare = qx(cmp --ignore-initial=$PARAM_s_ignore_bytes_compare --bytes=$PARAM_s_bytes_compare '$i_s_file1' '$i_s_file2');
		#print "FileComparator(...): $s_compare\n";
		if ($s_compare=~m/^\s*$/ )
		{
			
			# файлы не различаются
			$o_s_result_compare = 0;
		}
	}

	# 3. Возврат через return результата сравнения
	
	return($o_s_result_compare);
} # Конец FileComparator(...) 
#=================================================================


#=================================================================
# IV. Основная программа сравнения файлов
#=================================================================
system 'clear';

# Получение текущей даты
my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
my $nice_timestamp = sprintf ( "%02d.%02d.%04d %02d:%02d:%02d",
				$mday,$mon+1,$year+1900,$hour,$min,$sec);

# Печать заголовка отчета синхронизации директорий
print("\tОтчет от $nice_timestamp о синхронизации директории ИСТОЧНИКА
Файл ПРИЕМНИКА:\t$PARAM_s_start_dest_dir;
Файл ИСТОЧНИКА:\t$PARAM_s_start_source_dir.

Обозначения:
- \"$PARAM_s_archive_dir_name\" - имя директории в которую помещаются файлы ИСТОЧНИКА рядом с более новым файлом ПРИЕМНИКА, отличающимся по содержанию.
- \"$PARAM_s_suffix_old_file\" - суффикс перед расширением файла. Получают файлы ИСТОЧНИКА, если оказываются старее файлов ПРИЕМНИКА.
  Также помечаются файлы ИСТОЧНИКА в директориях \"$PARAM_s_archive_dir_name\" если есть отличающиеся аналоги.
  Больший номер после суффикса соответствует файлу, который позже остальных получил суффикс.\n\n");

# Вызов рекурсивной функции синхронизации директорий
my $s_num_recurse_run = RUN($PARAM_s_start_source_dir);

print("\nЧисло рекурсивно обойденных директорий в ИСТОЧНИКЕ - $s_num_recurse_run.\n");
